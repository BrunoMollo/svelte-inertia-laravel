---
description: How to maintain the seeders when adding new features
globs:
alwaysApply: true
---

## Cursor Rule: *Exhaustive and Representative Laravel Seeders*

**Principle**
Laravel database seeders **must exhaustively represent all meaningful domain states**, even with a small number of records. The goal is not volume, but **full coverage of the state space**.

**Rule**
When creating or modifying database seeders:

1. Seeders **must include at least one record for every relevant state, role, or meaningful combination** an entity can have.
2. Any new feature that **expands the possible states of the data model** requires:

   * Reviewing existing seeders.
   * Adding new records that explicitly represent the new states or combinations.
3. No valid model state should exist **only in theory or in production** — all must be visible in the development environment.

**Examples**

* If a `User` can be:

  * `admin`
  * `superadmin`
    → The seeder must create **at least one user of each role**.
* If a `blocked_at` flag is introduced:

  * active user
  * blocked user
    → The seeder must explicitly include **a blocked user**.
* If states or flags can be combined (e.g. `admin + blocked`), evaluate whether the combination is valid and, if so, **represent it in the seeder**.

**Goal**
The development environment should:

* Expose **all the ways data can appear**.
* Surface permission, logic, and UI bugs **before production**.
* Prevent implicit assumptions like *“this never happens”*.

**Pre-merge Mental Checklist**

* Did this feature introduce a new state, flag, or role?
* Is that state represented in the seeders?
* Can a new developer see this case by simply running `db:seed`?

> ❗ If a state exists in code but not in seeders, **the seeder is incomplete**.

---

## Using Factories in Seeders

**CRITICAL RULE**: When creating or modifying seeders, **always use factories** instead of directly calling model methods to create records.

### ❌ Don't Call Models Directly

```php
// Bad: Directly calling model methods
User::create([
    'name' => 'John Doe',
    'email' => 'john@example.com',
    'password' => Hash::make('password'),
]);

User::firstOrCreate(
    ['email' => 'john@example.com'],
    [
        'name' => 'John Doe',
        'password' => Hash::make('password'),
    ]
);
```

### ✅ Always Use Factories

```php
// Good: Using factories
User::factory()
    ->create([
        'name' => 'John Doe',
        'email' => 'john@example.com',
    ]);

User::factory()
    ->firstOrCreate(
        ['email' => 'john@example.com'],
        ['name' => 'John Doe']
    );
```

### Using Factory States

Factories often provide states for common scenarios. Use them:

```php
// Good: Using factory states
User::factory()
    ->disabled()
    ->create(['email' => 'disabled@example.com']);

Course::factory()
    ->published()
    ->withDateRange($startDate, $endDate)
    ->firstOrCreate(['name' => 'Published Course']);
```

### Combining Factory States with Overrides

You can combine factory states with attribute overrides:

```php
// Good: Factory state + specific attributes
User::factory()
    ->disabled()
    ->firstOrCreate(
        ['email' => 'disabled-teacher@example.com'],
        ['name' => 'Disabled Teacher']
    );
```

### Why Use Factories?

1. **Consistency**: Factories ensure all attributes are properly set according to the model's requirements
2. **Maintainability**: When model attributes change, factories are updated in one place
3. **Default values**: Factories provide sensible defaults for all fields
4. **Relationships**: Factories can handle relationships and complex setups
5. **Testing**: Same factories used in tests ensure consistency between test and seed data

### Exception: Third-Party Models

For third-party models (like Spatie Permission's `Role`), if no factory exists, direct model calls are acceptable:

```php
// Acceptable: Third-party model without factory
Role::firstOrCreate(['name' => 'superadmin']);
```

However, consider creating a factory even for third-party models if you use them frequently.

### Factory Requirements

When creating a new model:

1. **Always create a factory** using `php artisan make:model -mf`
2. **Update the factory** when model attributes change
3. **Use factory states** for common scenarios (e.g., `published()`, `disabled()`, `draft()`)
4. **Keep factories in sync** with migrations

### Pre-merge Checklist (Updated)

* Did this feature introduce a new state, flag, or role?
* Is that state represented in the seeders?
* **Are seeders using factories instead of direct model calls?**
* Can a new developer see this case by simply running `db:seed`?

> ❗ If a seeder calls model methods directly instead of using factories, **it violates this rule**.
